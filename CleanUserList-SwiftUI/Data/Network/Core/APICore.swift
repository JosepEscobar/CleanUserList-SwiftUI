import Foundation

/// Errors generated by the network layer
enum APIError: Error, Equatable {
    case networkError
    case decodingError
    case serverError(statusCode: Int)
    case responseError
    case timeout
    case unreachable
    case unknown(String)
    
    static func == (lhs: APIError, rhs: APIError) -> Bool {
        switch (lhs, rhs) {
        case (.networkError, .networkError),
             (.decodingError, .decodingError),
             (.responseError, .responseError),
             (.timeout, .timeout),
             (.unreachable, .unreachable):
            return true
        case (.serverError(let lhsCode), .serverError(let rhsCode)):
            return lhsCode == rhsCode
        case (.unknown(let lhsMessage), .unknown(let rhsMessage)):
            return lhsMessage == rhsMessage
        default:
            return false
        }
    }
    
    var localizedDescription: String {
        switch self {
        case .networkError:
            return "Network error: check your Internet connection"
        case .decodingError:
            return "Error decoding data"
        case .serverError(let statusCode):
            return "Server error: code \(statusCode)"
        case .responseError:
            return "Server response error"
        case .timeout:
            return "Request timeout"
        case .unreachable:
            return "Cannot connect to server"
        case .unknown(let message):
            return "Unknown error: \(message)"
        }
    }
}

/// Protocol for URLSession, allows injecting different implementations for testing
protocol URLSessionProtocol {
    func data(for request: URLRequest, delegate: URLSessionTaskDelegate?) async throws -> (Data, URLResponse)
}

extension URLSession: URLSessionProtocol {}

/// Protocol for DateFormatter, facilitates testing with dates
protocol DateFormatterProtocol {
    func string(from date: Date) -> String
    func date(from string: String) -> Date?
}

extension DateFormatter: DateFormatterProtocol {} 